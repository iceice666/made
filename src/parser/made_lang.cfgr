# Grammar for made-lang.

module made_lang;
program             : {0> statement} EOF;

block               : "{" {0> statement} "}";

statement           : variable_declaration
                     | typealias_declaration
                     | named_function_declaration
                     | while_statement
                     | for_statement
                     | return_statement
                     | break_statement
                     | continue_statement
                     | assignment_statement
                     | struct_declaration
                     | enum_declaration
                     | trait_declaration
                     | impl_declaration
                     | expression [";"];

variable_declaration : "let" IDENTIFIER [":" type] "=" expression ";";

typealias_declaration : "typealias" IDENTIFIER "=" type ";";

named_function_declaration : "func" IDENTIFIER function_signature block;

function_signature  : "(" parameter_list ")" [ "->" type ];

while_statement     : "while" expression block;

for_statement       : "for" IDENTIFIER "in" expression block;

return_statement    : "return" [expression] ";";

break_statement     : "break" ";";

continue_statement  : "continue" ";";

struct_declaration  : "struct" IDENTIFIER "{" field_list "}";

field_list          : { field $ "," };

field               : IDENTIFIER ":" type;

enum_declaration    : "enum" IDENTIFIER "{" variant_list "}";

variant_list        : { variant $ "," };

variant             : IDENTIFIER [ "(" type_list ")" | "{" field_list "}" ];

trait_declaration   : "trait" IDENTIFIER "{" {0> named_function_declaration} "}";

impl_declaration    : "impl" [ trait "for" ] type "{" {0> named_function_declaration} "}";

trait               : type;

assignment_statement : IDENTIFIER "=" expression ";";

expression          : if_expression
                     | match_expression
                     | lambda_declaration
                     | logical_or_expression;

logical_or_expression : logical_and_expression {0> ("or" | "||") logical_and_expression };

logical_and_expression : equality_expression {0> ("and" | "&&") equality_expression };

equality_expression : comparison_expression {0> ("==" | "!=") comparison_expression };

comparison_expression : additive_expression {0> (">" | "<" | ">=" | "<=") additive_expression };

additive_expression : multiplicative_expression {0> ("+" | "-") multiplicative_expression };

multiplicative_expression : unary_expression {0> ("*" | "/" | "%") unary_expression };

unary_expression    : ("+" | "-" | "not") unary_expression | primary_expression;

primary_expression  : literal
                     | IDENTIFIER
                     | "(" expression ")"
                     | function_call_expression
                     | field_access_expression;

if_expression       : "if" expression block [ "else" if_expression | block ];

match_expression    : "match" expression "{" {match_arm} "}";

match_arm           : { pattern $ "|" } "=>" block ";";

lambda_declaration  : function_signature block;

field_access_expression : primary_expression "." IDENTIFIER;

function_call_expression : primary_expression "(" (argument_list) ")";

parameter_list      : { parameter $ "," };

parameter           : IDENTIFIER ":" type;

argument_list       : { expression $ "," };

literal             : boolean_literal
                     | integer_literal
                     | float_literal
                     | char_literal
                     | string_literal;

boolean_literal     : "true" | "false";

integer_literal     : DIGIT {0> DIGIT|"'"};

float_literal       : integer_literal "." integer_literal;

char_literal        : "'" CHAR "'";

string_literal      : "\"" {0> CHAR} "\"";

type                : IDENTIFIER ( "<" type_list ">" );

type_list           : { type $ "," };

DIGIT               : regex("[0-9]");

CHAR                : regex("([^\"\\n\\r])");

IDENTIFIER          : {UNICODE / WHITESPACE};

WHITESPACE          : \u0009-\u000D | \u0020 | \u0085 | \u200E | \u200F | \u2028 | \u2029;

UNICODE             : \u0000-\uFFFF;

# vim: set syntax=cfgr:
